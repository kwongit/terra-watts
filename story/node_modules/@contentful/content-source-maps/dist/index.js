var J = { 0: 8203, 1: 8204, 2: 8205, 3: 8290, 4: 8291, 5: 8288, 6: 65279, 7: 8289, 8: 119155, 9: 119156, a: 119157, b: 119158, c: 119159, d: 119160, e: 119161, f: 119162 }, x = { 0: 8203, 1: 8204, 2: 8205, 3: 65279 }, R = new Array(4).fill(String.fromCodePoint(x[0])).join(""), L = "\0";
function k(e) {
  let t = JSON.stringify(e);
  return `${R}${Array.from(t).map((o) => {
    let n = o.charCodeAt(0);
    if (n > 255)
      throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${t} on character ${o} (${n})`);
    return Array.from(n.toString(4).padStart(4, "0")).map((r) => String.fromCodePoint(x[r])).join("");
  }).join("")}`;
}
function B(e) {
  return !Number.isNaN(Number(e)) || /[a-z]/i.test(e) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(e) ? !1 : !!Date.parse(e);
}
function D(e) {
  try {
    new URL(e, e.startsWith("/") ? "https://acme.com" : void 0);
  } catch (t) {
    return !1;
  }
  return !0;
}
function Q(e, t, o = "auto") {
  return o === !0 || o === "auto" && (B(e) || D(e)) ? e : `${e}${k(t)}`;
}
var z = Object.fromEntries(Object.entries(x).map((e) => e.reverse())), M = Object.fromEntries(Object.entries(J).map((e) => e.reverse())), G = `${Object.values(J).map((e) => `\\u{${e.toString(16)}}`).join("")}`, N = new RegExp(`[${G}]{4,}`, "gu");
function Z(e) {
  let t = e.match(N);
  if (t)
    return H(t[0], !0)[0];
}
function H(e, t = !1) {
  let o = Array.from(e);
  if (o.length % 2 === 0) {
    if (o.length % 4 || !e.startsWith(R))
      return K(o, t);
  } else
    throw new Error("Encoded data has invalid length");
  let n = [];
  for (let r = o.length * 0.25; r--; ) {
    let s = o.slice(r * 4, r * 4 + 4).map((i) => z[i.codePointAt(0)]).join("");
    n.unshift(String.fromCharCode(parseInt(s, 4)));
  }
  if (t) {
    n.shift();
    let r = n.indexOf(L);
    return r === -1 && (r = n.length), [JSON.parse(n.slice(0, r).join(""))];
  }
  return n.join("").split(L).filter(Boolean).map((r) => JSON.parse(r));
}
function K(e, t) {
  var o;
  let n = [];
  for (let c = e.length * 0.5; c--; ) {
    let u = `${M[e[c * 2].codePointAt(0)]}${M[e[c * 2 + 1].codePointAt(0)]}`;
    n.unshift(String.fromCharCode(parseInt(u, 16)));
  }
  let r = [], s = [n.join("")], i = 10;
  for (; s.length; ) {
    let c = s.shift();
    try {
      if (r.push(JSON.parse(c)), t)
        return r;
    } catch (u) {
      if (!i--)
        throw u;
      let f = +((o = u.message.match(/\sposition\s(\d+)$/)) == null ? void 0 : o[1]);
      if (!f)
        throw u;
      s.unshift(c.substring(0, f), c.substring(f));
    }
  }
  return r;
}
function X(e) {
  var t;
  return { cleaned: e.replace(N, ""), encoded: ((t = e.match(N)) == null ? void 0 : t[0]) || "" };
}
function O(e, t) {
  return Q(e, t);
}
function oe(e) {
  return k(e);
}
function se(e) {
  return Z(e);
}
function ce(e) {
  return X(e);
}
var Y = Object.prototype.hasOwnProperty, q = Object.prototype.toString, ee = function(t, o, n) {
  if (q.call(o) !== "[object Function]")
    throw new TypeError("iterator must be a function");
  var r = t.length;
  if (r === +r)
    for (var s = 0; s < r; s++)
      o.call(n, t[s], s, t);
  else
    for (var i in t)
      Y.call(t, i) && o.call(n, t[i], i, t);
}, te = ee, y = a;
function a(e, t, o) {
  if (arguments.length === 3)
    return a.set(e, t, o);
  if (arguments.length === 2)
    return a.get(e, t);
  var n = a.bind(a, e);
  for (var r in a)
    a.hasOwnProperty(r) && (n[r] = a[r].bind(n, e));
  return n;
}
a.get = function(t, o) {
  for (var n = Array.isArray(o) ? o : a.parse(o), r = 0; r < n.length; ++r) {
    var s = n[r];
    if (!(typeof t == "object" && s in t))
      throw new Error("Invalid reference token: " + s);
    t = t[s];
  }
  return t;
};
a.set = function(t, o, n) {
  var r = Array.isArray(o) ? o : a.parse(o), s = r[0];
  if (r.length === 0)
    throw Error("Can not set the root object");
  for (var i = 0; i < r.length - 1; ++i) {
    var c = r[i];
    typeof c != "string" && typeof c != "number" && (c = String(c)), !(c === "__proto__" || c === "constructor" || c === "prototype") && (c === "-" && Array.isArray(t) && (c = t.length), s = r[i + 1], c in t || (s.match(/^(\d+|-)$/) ? t[c] = [] : t[c] = {}), t = t[c]);
  }
  return s === "-" && Array.isArray(t) && (s = t.length), t[s] = n, this;
};
a.remove = function(e, t) {
  var o = Array.isArray(t) ? t : a.parse(t), n = o[o.length - 1];
  if (n === void 0)
    throw new Error('Invalid JSON pointer for remove: "' + t + '"');
  var r = a.get(e, o.slice(0, -1));
  if (Array.isArray(r)) {
    var s = +n;
    if (n === "" && isNaN(s))
      throw new Error('Invalid array index: "' + n + '"');
    Array.prototype.splice.call(r, s, 1);
  } else
    delete r[n];
};
a.dict = function(t, o) {
  var n = {};
  return a.walk(t, function(r, s) {
    n[s] = r;
  }, o), n;
};
a.walk = function(t, o, n) {
  var r = [];
  n = n || function(s) {
    var i = Object.prototype.toString.call(s);
    return i === "[object Object]" || i === "[object Array]";
  }, function s(i) {
    te(i, function(c, u) {
      r.push(String(u)), n(c) ? s(c) : o(c, a.compile(r)), r.pop();
    });
  }(t);
};
a.has = function(t, o) {
  try {
    a.get(t, o);
  } catch (n) {
    return !1;
  }
  return !0;
};
a.escape = function(t) {
  return t.toString().replace(/~/g, "~0").replace(/\//g, "~1");
};
a.unescape = function(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
};
a.parse = function(t) {
  if (t === "")
    return [];
  if (t.charAt(0) !== "/")
    throw new Error("Invalid JSON pointer: " + t);
  return t.substring(1).split(/\//).map(a.unescape);
};
a.compile = function(t) {
  return t.length === 0 ? "" : "/" + t.map(a.escape).join("/");
};
const ne = ({
  pointer: e,
  mappings: t,
  data: o,
  hiddenStrings: n
}) => {
  const r = t[e];
  delete t[e];
  const s = _(o, e);
  for (const i of s) {
    t[i] = r;
    const c = y.get(o, i), u = O(c, n);
    y.set(o, i, u);
  }
}, _ = (e, t = "") => {
  const o = [], n = y.get(e, t);
  if (n.content)
    for (let r = 0; r < n.content.length; r++)
      n.content[r].nodeType === "text" ? o.push(`${t}/content/${r}/value`) : o.push(..._(e, `${t}/content/${r}`));
  return o;
}, I = ({
  entityId: e,
  entityType: t,
  space: o,
  environment: n,
  field: r,
  locale: s,
  editorInterface: i,
  fieldType: c,
  targetOrigin: u
}) => ({
  origin: "contentful.com",
  href: `${`${u || "https://app.contentful.com"}/spaces/${o}/environments/${n}`}/${t === "Entry" ? "entries" : "assets"}/${e}/?focusedField=${r}&focusedLocale=${s}`,
  contentful: {
    space: o,
    environment: n,
    field: r,
    locale: s,
    entity: e,
    entityType: t,
    editorInterface: i,
    fieldType: c
  }
}), F = (e) => ["builtin", "sidebar-builtin", "editor-builtin"].includes(e), V = (e) => re.includes(e);
function U(e) {
  if (typeof structuredClone == "function")
    return structuredClone(e);
  try {
    return JSON.parse(JSON.stringify(e));
  } catch (t) {
    return console.warn("Failed to clone data:", e, t), e;
  }
}
const re = [
  "singleLine",
  "tagEditor",
  "listInput",
  "checkbox",
  "richTextEditor",
  "multipleLine",
  "markdown"
];
function C(e, t, o, n, r, s, i) {
  const c = i ? t[i] : t;
  switch (e) {
    case "Symbol": {
      const u = O(c, o);
      y.set(n, r, u);
      break;
    }
    case "RichText": {
      ne({
        pointer: "",
        mappings: s,
        data: c,
        hiddenStrings: o
      });
      break;
    }
    case "Array": {
      const u = c.map((f) => typeof f == "string" ? O(f, o) : f);
      y.set(n, r, u);
      break;
    }
  }
}
const ie = (e, t) => {
  if (!e || !e.extensions || !e.extensions.contentSourceMaps)
    return console.error(
      "GraphQL response does not contain Content Source Maps information.",
      e
    ), e;
  const o = U(
    e
  ), {
    spaces: n,
    environments: r,
    editorInterfaces: s,
    fields: i,
    locales: c,
    entries: u,
    assets: f,
    mappings: h,
    fieldTypes: m
  } = o.extensions.contentSourceMaps, p = o.data;
  for (const d in h) {
    const { source: l } = h[d], g = "entry" in l ? u[l.entry] : f[l.asset], v = "entry" in l ? "Entry" : "Asset";
    if (!g)
      return o;
    const w = n[g.space], A = r[g.environment], S = g.id, $ = i[l.field], W = c[l.locale], T = s[l.editorInterface], b = m[l.fieldType];
    if (!(F(T.widgetNamespace) && !V(T.widgetId)))
      if (y.has(p, d)) {
        const P = y.get(p, d);
        if (P !== null) {
          const j = I({
            entityId: S,
            entityType: v,
            space: w,
            environment: A,
            field: $,
            locale: W,
            editorInterface: T,
            fieldType: b,
            targetOrigin: t
          });
          C(b, P, j, p, d, h);
        }
      } else
        console.error(`Pointer ${d} not found in GraphQL data or href could not be generated.`);
  }
  return o;
}, E = (e, t, o, n) => {
  if (!e.fields)
    return;
  const { contentSourceMaps: r } = e.sys;
  if (!r) {
    console.error("Content source maps data is missing");
    return;
  }
  const { mappings: s } = r;
  for (const i in s) {
    const { source: c } = s[i], u = e.sys.space.sys.id, f = e.sys.environment.sys.id, h = e.sys.id, m = e.sys.type, p = t[c.fieldType], d = o[c.editorInterface];
    if (!(F(d.widgetNamespace) && !V(d.widgetId)))
      if (y.has(e, i)) {
        const l = y.get(e, i);
        if (l === null)
          return;
        const v = i.split("/").pop();
        if (!v) {
          console.error("Field name could not be extracted from the pointer", i);
          return;
        }
        const w = e.sys.locale;
        if (w) {
          const A = I({
            entityId: h,
            entityType: m,
            space: u,
            environment: f,
            field: v,
            locale: w,
            editorInterface: d,
            fieldType: p,
            targetOrigin: n
          });
          C(p, l, A, e, i, s);
        } else
          Object.keys(l).forEach((S) => {
            const $ = I({
              entityId: h,
              entityType: m,
              space: u,
              environment: f,
              field: v,
              locale: S,
              editorInterface: d,
              fieldType: p,
              targetOrigin: n
            });
            C(
              p,
              l,
              $,
              e,
              `${i}/${S}`,
              s,
              S
            );
          });
      } else
        console.error("Pointer not found in the target", i, e);
  }
}, ae = (e, t) => {
  const o = U(
    e
  );
  if (o.sys.type === "Array") {
    const n = o;
    if (!n.sys.contentSourceMapsLookup)
      return console.error("Content source maps lookup data is missing"), n;
    const {
      contentSourceMapsLookup: { fieldTypes: r, editorInterfaces: s }
    } = n.sys, { items: i, includes: c } = n;
    i.forEach((u) => E(u, r, s, t)), c && c.Entry && c.Entry.forEach(
      (u) => E(u, r, s, t)
    ), c && c.Asset && c.Asset.forEach(
      (u) => E(u, r, s, t)
    );
  } else {
    const n = o;
    if (!n.sys.contentSourceMapsLookup)
      return console.error("Content source maps lookup data is missing"), n;
    E(
      n,
      n.sys.contentSourceMapsLookup.fieldTypes,
      n.sys.contentSourceMapsLookup.editorInterfaces,
      t
    );
  }
  return o;
};
export {
  re as SUPPORTED_WIDGETS,
  U as clone,
  O as combine,
  I as createSourceMapMetadata,
  se as decode,
  oe as encode,
  ae as encodeCPAResponse,
  C as encodeField,
  ie as encodeGraphQLResponse,
  ne as encodeRichTextValue,
  F as isBuiltinNamespace,
  V as isSupportedWidget,
  ce as splitEncoding
};
//# sourceMappingURL=index.js.map
